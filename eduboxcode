import tkinter as tk
from tkinter import ttk, messagebox
import json
import os
import cv2
import mediapipe as mp
from openpyxl import Workbook, load_workbook
import threading
import time


class BasicQuiz:
    def __init__(self):
        self.colors = {
            "bg": "#1e1e2e",
            "fg": "#cdd6f4",
            "accent": "#89b4fa",
            "button_bg": "#808080",
            "button_fg": "#000000",
            "button_hover": "#45475a",
            "success": "#a6e3a1",
            "error": "#f38ba8",
            "warning": "#fab387"
        }
        self.questions_file = "questions.json"
        self.students_file = "students.json"
        self.scores_file = "scores.xlsx"
        self.questions = self.load_questions()
        self.students = self.load_students()
        self.root = tk.Tk()
        self.root.title("EduBox Quiz System")
        self.root.attributes("-fullscreen", True)
        
        # Modern styling
        self.setup_styles()
        self.root.configure(bg=self.colors["bg"])
        
        # Bind ESC to exit fullscreen
        self.root.bind("<Escape>", lambda e: self.root.attributes("-fullscreen", False))
        
        self.create_main_menu()

        # Add feedback and next button variables - Fixed initialization
        self.show_feedback = False
        self.feedback_timer = 0
        self.feedback_message = ""
        self.feedback_color = (255, 255, 255)
        self.show_next_button = False
        self.answered_current_question = False
        
        # Initialize student interface variables
        self.student_step = 1
        self.selected_name = None
        self.selected_qtype = None
        self.current_questions = []
        self.current_question_idx = 0
        self.student_score = 0
        self.selection_boxes = []
        self.selection_timer = 0
        self.selection_threshold = 30  # REDUCED from 60 to 30 for faster selection
        self.hover_option = None
        self.question_answered = False  # Track if current question was answered
        
        # Initialize MediaPipe variables
        self.mp_hands = None
        self.mp_drawing = None
        self.hands = None

        # Add drag and drop specific variables
        self.dd_selected_items = []  # Track selected items in order
        self.dd_drop_zones = []  # Drop zone positions
        self.dd_dragging_item = None  # Currently selected item for dragging
        self.dd_drag_timer = 0  # Timer for drag selection
        self.dd_selection_mode = True  # True for selecting items, False for confirming

        # Add this flag to control camera loop exit
        self.exit_camera = False

    def setup_styles(self):
        style = ttk.Style()
        style.theme_use("clam")
        
        # Configure modern styles
        style.configure("Modern.TButton", 
                       background=self.colors["button_bg"],
                       foreground=self.colors["button_fg"],
                       borderwidth=0,
                       focuscolor="none",
                       padding=(20, 10))
        
        style.map("Modern.TButton",
                 background=[('active', self.colors["button_hover"]),
                           ('pressed', self.colors["accent"])])
        
        style.configure("Modern.TNotebook", 
                       background=self.colors["bg"],
                       borderwidth=0)
        
        style.configure("Modern.TNotebook.Tab",
                       background=self.colors["button_bg"],
                       foreground=self.colors["button_fg"],
                       padding=(20, 10))
        
        style.map("Modern.TNotebook.Tab",
                 background=[('selected', self.colors["accent"]),
                           ('active', self.colors["button_hover"])])

    # -------- Data helpers --------
    def load_questions(self):
        if os.path.exists(self.questions_file):
            try:
                with open(self.questions_file, "r") as f:
                    return json.load(f)
            except (json.JSONDecodeError, FileNotFoundError):
                return {"multiple_choice": [], "drag_drop": [], "matching": [], "true_false": []}
        return {"multiple_choice": [], "drag_drop": [], "matching": [], "true_false": []}

    def save_questions(self):
        try:
            with open(self.questions_file, "w") as f:
                json.dump(self.questions, f, indent=2)
        except Exception as e:
            messagebox.showerror("Error", f"Could not save questions: {str(e)}")

    def load_students(self):
        if os.path.exists(self.students_file):
            try:
                with open(self.students_file, "r") as f:
                    return json.load(f)
            except (json.JSONDecodeError, FileNotFoundError):
                return []
        return []

    def save_students(self):
        try:
            with open(self.students_file, "w") as f:
                json.dump(self.students, f, indent=2)
        except Exception as e:
            messagebox.showerror("Error", f"Could not save students: {str(e)}")

    def save_score(self, name, score):
        try:
            if not os.path.exists(self.scores_file):
                wb = Workbook()
                ws = wb.active
                ws.append(["Name", "Score"])
                wb.save(self.scores_file)
            
            wb = load_workbook(self.scores_file)
            ws = wb.active
            ws.append([name, score])
            wb.save(self.scores_file)
        except Exception as e:
            messagebox.showerror("Error", f"Could not save score: {str(e)}")

    # -------- UI helpers --------
    def clear_root(self):
        for w in self.root.winfo_children():
            w.destroy()

    def create_modern_button(self, master, text, command, width=200, height=50):
        button = tk.Button(
            master, 
            text=text, 
            command=command,
            bg=self.colors["button_bg"],
            fg=self.colors["button_fg"],
            font=("SF Pro Display", 14, "bold"),
            relief="flat",
            bd=0,
            width=width//8,
            height=height//20,
            cursor="hand2"
        )
        # Hover effects
        button.bind("<Enter>", lambda e: button.config(bg=self.colors["button_hover"]))
        button.bind("<Leave>", lambda e: button.config(bg=self.colors["button_bg"]))
        return button

    def create_title_label(self, master, text, size=32):
        return tk.Label(
            master,
            text=text,
            font=("SF Pro Display", size, "bold"),
            bg=self.colors["bg"],
            fg=self.colors["accent"]
        )

    def create_subtitle_label(self, master, text, size=16):
        return tk.Label(
            master,
            text=text,
            font=("SF Pro Text", size),
            bg=self.colors["bg"],
            fg=self.colors["fg"]
        )

    # -------- Main Menu --------
    def create_main_menu(self):
        self.clear_root()
        
        # Main container
        main_frame = tk.Frame(self.root, bg=self.colors["bg"])
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Center content
        center_frame = tk.Frame(main_frame, bg=self.colors["bg"])
        center_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        # Title
        title = self.create_title_label(center_frame, "üéì EduBox Quiz System", 48)
        title.pack(pady=(0, 20))
        
        # Subtitle
        subtitle = self.create_subtitle_label(center_frame, "Interactive Learning Platform", 18)
        subtitle.pack(pady=(0, 50))
        
        # Buttons frame
        buttons_frame = tk.Frame(center_frame, bg=self.colors["bg"])
        buttons_frame.pack()
        
        # Teacher Mode Button
        teacher_btn = self.create_modern_button(buttons_frame, "üë®‚Äçüè´ Teacher Mode", self.open_teacher)
        teacher_btn.pack(pady=15)
        
        # Student Mode Button
        student_btn = self.create_modern_button(buttons_frame, "üë®‚Äçüéì Student Mode", self.open_student)
        student_btn.pack(pady=15)
        
        # Exit Button
        exit_btn = self.create_modern_button(buttons_frame, "üö™ Exit", self.root.quit)
        exit_btn.pack(pady=15)

    # -------- Teacher Interface --------
    def open_teacher(self):
        self.clear_root()
        
        # Header
        header_frame = tk.Frame(self.root, bg=self.colors["bg"], height=80)
        header_frame.pack(fill=tk.X, padx=20, pady=10)
        header_frame.pack_propagate(False)
        
        # Back button
        back_btn = self.create_modern_button(header_frame, "‚Üê Back", self.create_main_menu, 100, 40)
        back_btn.pack(side=tk.LEFT, pady=10)
        
        # Title
        title = self.create_title_label(header_frame, "Teacher Dashboard", 24)
        title.pack(side=tk.LEFT, padx=(20, 0), pady=10)
        
        # Notebook with modern styling
        notebook = ttk.Notebook(self.root, style="Modern.TNotebook")
        notebook.pack(fill=tk.BOTH, expand=True, padx=20, pady=(0, 20))
        
        # Create tabs - ADD DRAG & DROP TAB
        self.create_mc_tab(notebook)
        self.create_tf_tab(notebook)
        self.create_drag_drop_tab(notebook)  # Add this line
        self.create_view_questions_tab(notebook)
        self.create_add_student_tab(notebook)
        self.create_scores_tab(notebook)

    def create_mc_tab(self, nb):
        frame = ttk.Frame(nb)
        nb.add(frame, text="üìù Multiple Choice")
        
        # Container with padding
        container = tk.Frame(frame, bg=self.colors["bg"])
        container.pack(fill=tk.BOTH, expand=True, padx=40, pady=30)
        
        # Question input
        tk.Label(container, text="Question:", font=("SF Pro Text", 16, "bold"),
                bg=self.colors["bg"], fg=self.colors["fg"]).pack(anchor="w", pady=(0, 10))
        
        self.mc_q = tk.Entry(container, font=("SF Pro Text", 14), width=80, 
                            bg=self.colors["button_bg"], fg=self.colors["fg"], 
                            insertbackground=self.colors["fg"], relief="flat", bd=10)
        self.mc_q.pack(pady=(0, 20), ipady=8)
        
        # Options frame
        options_frame = tk.Frame(container, bg=self.colors["bg"])
        options_frame.pack(fill=tk.X, pady=(0, 30))
        
        self.mc_opts = {}
        for i, letter in enumerate(["A", "B", "C", "D"]):
            opt_frame = tk.Frame(options_frame, bg=self.colors["bg"])
            opt_frame.pack(fill=tk.X, pady=5)
            
            tk.Label(opt_frame, text=f"Option {letter}:", font=("SF Pro Text", 14),
                    bg=self.colors["bg"], fg=self.colors["fg"], width=10).pack(side=tk.LEFT)
            
            entry = tk.Entry(opt_frame, font=("SF Pro Text", 12), width=50,
                           bg=self.colors["button_bg"], fg=self.colors["fg"],
                           insertbackground=self.colors["fg"], relief="flat", bd=5)
            entry.pack(side=tk.LEFT, padx=(10, 20), ipady=5)
            
            chk = tk.BooleanVar()
            check = tk.Checkbutton(opt_frame, text="Correct", variable=chk,
                                 font=("SF Pro Text", 12),
                                 bg=self.colors["bg"], fg=self.colors["fg"],
                                 selectcolor=self.colors["accent"],
                                 activebackground=self.colors["bg"])
            check.pack(side=tk.LEFT)
            
            self.mc_opts[letter] = (entry, chk)
        
        # Add button
        add_btn = self.create_modern_button(container, "‚ûï Add Question", self.add_mc)
        add_btn.pack(pady=20)

    def create_tf_tab(self, nb):
        frame = ttk.Frame(nb)
        nb.add(frame, text="‚úÖ True/False")
        
        container = tk.Frame(frame, bg=self.colors["bg"])
        container.pack(fill=tk.BOTH, expand=True, padx=40, pady=30)
        
        tk.Label(container, text="Question:", font=("SF Pro Text", 16, "bold"),
                bg=self.colors["bg"], fg=self.colors["fg"]).pack(anchor="w", pady=(0, 10))
        
        self.tf_q = tk.Entry(container, font=("SF Pro Text", 14), width=80,
                           bg=self.colors["button_bg"], fg=self.colors["fg"],
                           insertbackground=self.colors["fg"], relief="flat", bd=10)
        self.tf_q.pack(pady=(0, 30), ipady=8)
        
        # Answer selection
        answer_frame = tk.Frame(container, bg=self.colors["bg"])
        answer_frame.pack(pady=(0, 30))
        
        tk.Label(answer_frame, text="Correct Answer:", font=("SF Pro Text", 14, "bold"),
                bg=self.colors["bg"], fg=self.colors["fg"]).pack(pady=(0, 10))
        
        self.tf_var = tk.StringVar(value="True")
        
        true_btn = tk.Radiobutton(answer_frame, text="True", variable=self.tf_var, value="True",
                                font=("SF Pro Text", 12), bg=self.colors["bg"], fg=self.colors["fg"],
                                selectcolor=self.colors["accent"], activebackground=self.colors["bg"])
        true_btn.pack(side=tk.LEFT, padx=20)
        
        false_btn = tk.Radiobutton(answer_frame, text="False", variable=self.tf_var, value="False",
                                 font=("SF Pro Text", 12), bg=self.colors["bg"], fg=self.colors["fg"],
                                 selectcolor=self.colors["accent"], activebackground=self.colors["bg"])
        false_btn.pack(side=tk.LEFT, padx=20)
        
        add_btn = self.create_modern_button(container, "‚ûï Add Question", self.add_tf)
        add_btn.pack(pady=20)

    def create_drag_drop_tab(self, nb):
        frame = ttk.Frame(nb)
        nb.add(frame, text="üîÑ Drag & Drop")
        
        container = tk.Frame(frame, bg=self.colors["bg"])
        container.pack(fill=tk.BOTH, expand=True, padx=40, pady=30)
        
        # Question input
        tk.Label(container, text="Question:", font=("SF Pro Text", 16, "bold"),
                bg=self.colors["bg"], fg=self.colors["fg"]).pack(anchor="w", pady=(0, 10))
        
        self.dd_q = tk.Entry(container, font=("SF Pro Text", 14), width=80,
                            bg=self.colors["button_bg"], fg=self.colors["fg"],
                            insertbackground=self.colors["fg"], relief="flat", bd=10)
        self.dd_q.pack(pady=(0, 20), ipady=8)
        
        # Instructions
        tk.Label(container, text="Enter items to be arranged in correct order (1 = first, 2 = second, etc.)",
                font=("SF Pro Text", 12), bg=self.colors["bg"], fg=self.colors["fg"]).pack(anchor="w", pady=(0, 20))
        
        # Items frame
        items_frame = tk.Frame(container, bg=self.colors["bg"])
        items_frame.pack(fill=tk.X, pady=(0, 30))
        
        self.dd_items = {}
        for i in range(4):  # Allow up to 4 items
            item_frame = tk.Frame(items_frame, bg=self.colors["bg"])
            item_frame.pack(fill=tk.X, pady=5)
            
            tk.Label(item_frame, text=f"Item {i+1}:", font=("SF Pro Text", 14),
                    bg=self.colors["bg"], fg=self.colors["fg"], width=8).pack(side=tk.LEFT)
            
            entry = tk.Entry(item_frame, font=("SF Pro Text", 12), width=40,
                            bg=self.colors["button_bg"], fg=self.colors["fg"],
                            insertbackground=self.colors["fg"], relief="flat", bd=5)
            entry.pack(side=tk.LEFT, padx=(10, 20), ipady=5)
            
            tk.Label(item_frame, text="Position:", font=("SF Pro Text", 12),
                    bg=self.colors["bg"], fg=self.colors["fg"]).pack(side=tk.LEFT, padx=(0, 5))
            
            pos_var = tk.StringVar(value=str(i+1))
            pos_entry = tk.Entry(item_frame, textvariable=pos_var, font=("SF Pro Text", 12), width=5,
                               bg=self.colors["button_bg"], fg=self.colors["fg"],
                               insertbackground=self.colors["fg"], relief="flat", bd=5)
            pos_entry.pack(side=tk.LEFT, ipady=5)
            
            self.dd_items[i] = (entry, pos_var)
        
        # Add button
        add_btn = self.create_modern_button(container, "‚ûï Add Question", self.add_dd)
        add_btn.pack(pady=20)

    def create_add_student_tab(self, nb):
        frame = ttk.Frame(nb)
        nb.add(frame, text="üë§ Add Student")
        
        container = tk.Frame(frame, bg=self.colors["bg"])
        container.pack(fill=tk.BOTH, expand=True, padx=40, pady=30)
        
        # Add Student Section
        add_section = tk.Frame(container, bg=self.colors["bg"])
        add_section.pack(fill=tk.X, pady=(0, 30))
        
        tk.Label(add_section, text="Add New Student:", font=("SF Pro Text", 18, "bold"),
                bg=self.colors["bg"], fg=self.colors["accent"]).pack(anchor="w", pady=(0, 15))
        
        tk.Label(add_section, text="Student Name:", font=("SF Pro Text", 16, "bold"),
                bg=self.colors["bg"], fg=self.colors["fg"]).pack(anchor="w", pady=(0, 10))
        
        self.student_entry = tk.Entry(add_section, font=("SF Pro Text", 14), width=50,
                                    bg=self.colors["button_bg"], fg=self.colors["fg"],
                                    insertbackground=self.colors["fg"], relief="flat", bd=10)
        self.student_entry.pack(pady=(0, 20), ipady=8)
        
        add_btn = self.create_modern_button(add_section, "‚ûï Add Student", self.add_student)
        add_btn.pack()
        
        # Separator line
        separator = tk.Frame(container, height=2, bg=self.colors["accent"])
        separator.pack(fill=tk.X, pady=30)
        
        # Students List Section
        list_section = tk.Frame(container, bg=self.colors["bg"])
        list_section.pack(fill=tk.BOTH, expand=True)
        
        # Header for students list
        list_header = tk.Frame(list_section, bg=self.colors["bg"])
        list_header.pack(fill=tk.X, pady=(0, 20))
        
        tk.Label(list_header, text="Current Students:", font=("SF Pro Text", 18, "bold"),
                bg=self.colors["bg"], fg=self.colors["accent"]).pack(side=tk.LEFT)
        
        refresh_btn = self.create_modern_button(list_header, "üîÑ Refresh", self.refresh_student_list, 120, 35)
        refresh_btn.pack(side=tk.RIGHT)
        
        # Frame for the listbox and scrollbar
        listbox_frame = tk.Frame(list_section, bg=self.colors["bg"])
        listbox_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 20))
        
        # Listbox for students with scrollbar
        self.students_listbox = tk.Listbox(listbox_frame, font=("SF Pro Text", 14), height=15,
                                         bg=self.colors["button_bg"], fg=self.colors["fg"],
                                         selectbackground=self.colors["accent"],
                                         selectforeground="white",
                                         relief="flat", bd=5, activestyle="none")
        
        # Scrollbar for listbox
        listbox_scrollbar = tk.Scrollbar(listbox_frame, orient=tk.VERTICAL, command=self.students_listbox.yview)
        self.students_listbox.configure(yscrollcommand=listbox_scrollbar.set)
        
        self.students_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        listbox_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Buttons frame for student management
        buttons_frame = tk.Frame(list_section, bg=self.colors["bg"])
        buttons_frame.pack(fill=tk.X, pady=(0, 10))
        
        delete_btn = self.create_modern_button(buttons_frame, "üóëÔ∏è Delete Selected", self.delete_student)
        delete_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        clear_all_btn = self.create_modern_button(buttons_frame, "üóëÔ∏è Clear All Students", self.clear_all_students)
        clear_all_btn.pack(side=tk.LEFT, padx=10)
        
        # Student count label
        self.student_count_label = tk.Label(list_section, text="", font=("SF Pro Text", 12),
                                          bg=self.colors["bg"], fg=self.colors["fg"])
        self.student_count_label.pack(anchor="w", pady=(10, 0))
        
        # Load students initially
        self.refresh_student_list()

    def create_scores_tab(self, nb):
        frame = ttk.Frame(nb)
        nb.add(frame, text="üìä View Scores")
        
        container = tk.Frame(frame, bg=self.colors["bg"])
        container.pack(fill=tk.BOTH, expand=True, padx=40, pady=30)
        
        tk.Label(container, text="Student Total Scores:", font=("SF Pro Text", 16, "bold"),
                bg=self.colors["bg"], fg=self.colors["fg"]).pack(anchor="w", pady=(0, 20))
        
        self.score_text = tk.Text(container, font=("SF Mono", 12), width=80, height=25,
                                bg=self.colors["button_bg"], fg="black",  # Changed to black
                                insertbackground="black", relief="flat", bd=10)  # Changed to black
        self.score_text.pack(pady=(0, 20))
        
        # Add buttons frame for additional controls
        buttons_frame = tk.Frame(container, bg=self.colors["bg"])
        buttons_frame.pack(pady=(0, 10))
        
        refresh_btn = self.create_modern_button(buttons_frame, "üîÑ Refresh", self.load_scores)
        refresh_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        clear_scores_btn = self.create_modern_button(buttons_frame, "üóëÔ∏è Clear All Scores", self.clear_all_scores)
        clear_scores_btn.pack(side=tk.LEFT)
        
        self.load_scores()

    def create_view_questions_tab(self, nb):
        frame = ttk.Frame(nb)
        nb.add(frame, text="üìã View Questions")
        
        container = tk.Frame(frame, bg=self.colors["bg"])
        container.pack(fill=tk.BOTH, expand=True, padx=40, pady=30)
        
        # Header
        tk.Label(container, text="All Questions:", font=("SF Pro Text", 16, "bold"),
                bg=self.colors["bg"], fg=self.colors["fg"]).pack(anchor="w", pady=(0, 20))
        
        # Question type selector
        type_frame = tk.Frame(container, bg=self.colors["bg"])
        type_frame.pack(fill=tk.X, pady=(0, 20))
        
        tk.Label(type_frame, text="Filter by type:", font=("SF Pro Text", 14),
                bg=self.colors["bg"], fg=self.colors["fg"]).pack(side=tk.LEFT, padx=(0, 10))
        
        self.view_qtype_var = tk.StringVar(value="all")
        
        type_options = [
            ("all", "All Questions"),
            ("multiple_choice", "Multiple Choice"),
            ("true_false", "True/False"),
            ("drag_drop", "Drag & Drop")  # Add this line
        ]
        
        for value, text in type_options:
            rb = tk.Radiobutton(type_frame, text=text, variable=self.view_qtype_var, value=value,
                               font=("SF Pro Text", 12), bg=self.colors["bg"], fg=self.colors["fg"],
                               selectcolor=self.colors["accent"], activebackground=self.colors["bg"],
                               command=self.refresh_questions_view)
            rb.pack(side=tk.LEFT, padx=10)
        
        # Scrollable text area for questions
        text_frame = tk.Frame(container, bg=self.colors["bg"])
        text_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 20))
        
        self.questions_text = tk.Text(text_frame, font=("SF Mono", 11), width=100, height=30,
                                    bg=self.colors["button_bg"], fg=self.colors["fg"],
                                    insertbackground=self.colors["fg"], relief="flat", bd=10,
                                    wrap=tk.WORD, state=tk.DISABLED)
        
        # Scrollbar for the text widget
        scrollbar = tk.Scrollbar(text_frame, orient=tk.VERTICAL, command=self.questions_text.yview)
        self.questions_text.configure(yscrollcommand=scrollbar.set)
        
        self.questions_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Buttons frame
        buttons_frame = tk.Frame(container, bg=self.colors["bg"])
        buttons_frame.pack(fill=tk.X)
        
        refresh_btn = self.create_modern_button(buttons_frame, "üîÑ Refresh", self.refresh_questions_view)
        refresh_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        clear_btn = self.create_modern_button(buttons_frame, "üóëÔ∏è Clear All Questions", self.clear_all_questions)
        clear_btn.pack(side=tk.LEFT, padx=10)
        
        # Load questions initially
        self.refresh_questions_view()

    def delete_question(self, qtype, index):
        """Delete a specific question by type and index."""
        try:
            question_list = self.questions.get(qtype, [])
            if index < len(question_list):
                question_list.pop(index)
                self.questions[qtype] = question_list
                self.save_questions()
                self.refresh_questions_view()
                messagebox.showinfo("Success", "Question deleted successfully!")
            else:
                messagebox.showerror("Error", "Invalid question index!")
        except Exception as e:
            messagebox.showerror("Error", f"Could not delete question: {str(e)}")

    def refresh_questions_view(self):
        """Refresh the questions display based on selected filter"""
        self.questions_text.config(state=tk.NORMAL)
        self.questions_text.delete("1.0", tk.END)
        
        filter_type = self.view_qtype_var.get()
        
        if filter_type == "all":
            question_types = ["multiple_choice", "true_false", "drag_drop"]
        else:
            question_types = [filter_type]
        
        total_questions = 0
        
        for qtype in question_types:
            questions_list = self.questions.get(qtype, [])
            if not questions_list:
                continue
                
            # Add section header
            type_name = {
                "multiple_choice": "Multiple Choice",
                "true_false": "True/False",
                "drag_drop": "Drag & Drop"
            }.get(qtype, qtype)
            
            self.questions_text.insert(tk.END, f"\n{'='*60}\n")
            self.questions_text.insert(tk.END, f"üìù {type_name.upper()} QUESTIONS ({len(questions_list)} total)\n")
            self.questions_text.insert(tk.END, f"{'='*60}\n\n")
            
            for i, q in enumerate(questions_list, 1):
                self.questions_text.insert(tk.END, f"Question #{i}:\n")
                self.questions_text.insert(tk.END, f"‚ùì {q.get('question', 'No question text')}\n\n")
                
                if qtype == "multiple_choice":
                    options = q.get("options", {})
                    correct = q.get("correct", [])
                    
                    for opt_key, opt_value in options.items():
                        marker = "‚úÖ" if opt_key in correct else "‚≠ï"
                        self.questions_text.insert(tk.END, f"   {marker} {opt_key}) {opt_value}\n")
                    
                    self.questions_text.insert(tk.END, f"\nüí° Correct Answer(s): {', '.join(correct)}\n")
                    
                elif qtype == "true_false":
                    answer = q.get("answer", "")
                    self.questions_text.insert(tk.END, f"üí° Correct Answer: {answer}\n")
                
                elif qtype == "drag_drop":
                    items = q.get("items", {})
                    correct_order = q.get("correct_order", {})
                    
                    self.questions_text.insert(tk.END, "üîÑ Items to arrange:\n")
                    for item_key, item_value in items.items():
                        position = correct_order.get(item_key, "?")
                        self.questions_text.insert(tk.END, f"   üìå {item_value} (Position: {position})\n")
                    
                    # Show correct order
                    sorted_items = sorted(items.items(), key=lambda x: correct_order.get(x[0], 0))
                    self.questions_text.insert(tk.END, f"\nüí° Correct Order: ")
                    order_text = " ‚Üí ".join([items[item_key] for item_key, _ in sorted_items])
                    self.questions_text.insert(tk.END, f"{order_text}\n")
            
            # Add delete button for each question
            delete_btn = tk.Button(
                self.questions_text, 
                text="üóëÔ∏è Delete", 
                command=lambda qtype=qtype, index=i-1: self.delete_question(qtype, index),
                bg=self.colors["error"], 
                fg="black",
                relief="flat", 
                cursor="hand2"
            )
            self.questions_text.window_create(tk.END, window=delete_btn)
            self.questions_text.insert(tk.END, "\n\n")
            
            self.questions_text.insert(tk.END, f"\n{'-'*50}\n\n")
            total_questions += 1
    
        if total_questions == 0:
            self.questions_text.insert(tk.END, "\nüìù No questions found.\n\n")
            self.questions_text.insert(tk.END, "‚ÑπÔ∏è  Use the question tabs to add questions.\n")
        else:
            self.questions_text.insert(tk.END, f"\nüìä Total Questions Displayed: {total_questions}\n")
    
        self.questions_text.config(state=tk.DISABLED)
        self.questions_text.see("1.0")

    def clear_all_questions(self):
        """Clear all questions with confirmation"""
        result = messagebox.askyesno(
            "Clear All Questions", 
            "Are you sure you want to delete ALL questions?\n\nThis action cannot be undone!",
            icon="warning"
        )
        
        if result:
            self.questions = {"multiple_choice": [], "drag_drop": [], "matching": [], "true_false": []}
            self.save_questions()
            self.refresh_questions_view()
            messagebox.showinfo("Success", "All questions have been cleared!")

    # -------- Student Interface with Full Gesture Control --------
    def open_student(self):
        # Check if students exist
        if not self.students:
            messagebox.showwarning("No Students", "Please add students first in Teacher Mode!")
            return
            
        # Check if questions exist
        total_questions = sum(len(questions) for questions in self.questions.values())
        if total_questions == 0:
            messagebox.showwarning("No Questions", "Please add questions first in Teacher Mode!")
            return
            
        self.clear_root()
        
        # Reset student interface variables
        self.student_step = 1
        self.selected_name = None
        self.selected_qtype = None
        self.current_questions = []
        self.current_question_idx = 0
        self.student_score = 0
        self.selection_boxes = []
        self.selection_timer = 0
        self.hover_option = None
        self.question_answered = False  # Add this line
        
        # Initialize hand tracking
        try:
            self.mp_hands = mp.solutions.hands
            self.mp_drawing = mp.solutions.drawing_utils
            self.hands = self.mp_hands.Hands(min_detection_confidence=0.7, min_tracking_confidence=0.5)
        except Exception as e:
            messagebox.showerror("MediaPipe Error", f"Could not initialize hand tracking: {str(e)}")
            return
        
        # Start camera-based interface
        self.run_camera_interface()

    def run_camera_interface(self):
        # Reset the exit flag
        self.exit_camera = False
        
        try:
            cap = cv2.VideoCapture(0)
            if not cap.isOpened():
                messagebox.showerror("Error", "Cannot access camera")
                return
                
            while True:
                # Check if we should exit the camera loop
                if self.exit_camera:
                    break
                    
                ret, frame = cap.read()
                if not ret:
                    break
                    
                frame = cv2.flip(frame, 1)
                h, w = frame.shape[:2]
                
                # Process hand detection
                rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                result = self.hands.process(rgb)
                
                # Draw interface based on current step
                if self.student_step == 1:
                    self.draw_name_selection(frame, w, h)
                elif self.student_step == 2:
                    self.draw_question_type_selection(frame, w, h)
                elif self.student_step == 3:
                    if self.current_question_idx < len(self.current_questions):
                        q = self.current_questions[self.current_question_idx]
                        self.draw_quiz_interface(frame, q, w, h)
                    else:
                        self.student_step = 4
                elif self.student_step == 4:
                    self.draw_results_interface(frame, w, h)
                
                # Handle hand gestures
                if result.multi_hand_landmarks:
                    self.handle_camera_gestures(frame, result, w, h)
                else:
                    self.selection_timer = 0
                    self.hover_option = None
                
                cv2.imshow("EduBox - Student Interface (Press Q to Exit)", frame)
                
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    break
                    
        except Exception as e:
            messagebox.showerror("Camera Error", f"Camera interface error: {str(e)}")
        finally:
            if 'cap' in locals():
                cap.release()
            cv2.destroyAllWindows()
            
            # Return to main menu after camera cleanup
            self.create_main_menu()

    def draw_name_selection(self, frame, w, h):
        # Header with dark blue background
        cv2.rectangle(frame, (0, 0), (w, 100), (139, 69, 19), -1)  # Dark blue background
        cv2.putText(frame, "Step 1/3: Select Your Name", (20, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255, 255, 255), 3)  # White bold text
        cv2.putText(frame, "Point to your name and hold for 2 seconds", (20, 65), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)  # White bold text
        
        # Center student name boxes - made bigger
        self.selection_boxes = []
        box_width = 450  # Increased from 350
        box_height = 100  # Increased from 80
        names_per_row = 2
        row_spacing = 120  # Increased spacing
        col_spacing = 60  # Increased spacing
        
        # Calculate starting position to center all boxes (moved down)
        total_width = (box_width * names_per_row) + (col_spacing * (names_per_row - 1))
        start_x = (w - total_width) // 2
        start_y = 200  # Moved down from 150
        
        for i, name in enumerate(self.students):
            row = i // names_per_row
            col = i % names_per_row
            
            x = start_x + (col * (box_width + col_spacing))
            y = start_y + (row * row_spacing)
            
            if y + box_height > h - 100:  # Don't draw outside frame
                break
                
            box = [x, y, x + box_width, y + box_height]
            
            # Highlight if hovering
            color = (137, 180, 250) if self.hover_option == name else (139, 69, 19)  # Changed to dark blue
            thickness = 6 if self.hover_option == name else 3
            
            cv2.rectangle(frame, (box[0], box[1]), (box[2], box[3]), color, thickness)
            cv2.rectangle(frame, (box[0]+3, box[1]+3), (box[2]-3, box[3]-3), (139, 69, 19), -1)  # Dark blue background
            
            # Center name text - white bold and larger
            text_size = cv2.getTextSize(name, cv2.FONT_HERSHEY_SIMPLEX, 1.3, 4)[0]  # Increased from 1.0, 3
            text_x = box[0] + (box_width - text_size[0]) // 2
            text_y = box[1] + (box_height + text_size[1]) // 2
            cv2.putText(frame, name, (text_x, text_y), 
                       cv2.FONT_HERSHEY_SIMPLEX, 1.3, (255, 255, 255), 4)  # Larger and bolder text
            
            # Draw selection progress with green color
            if self.hover_option == name and self.selection_timer > 0:
                progress_width = int((self.selection_timer / self.selection_threshold) * (box[2] - box[0] - 10))
                cv2.rectangle(frame, (box[0] + 5, box[3] - 20), 
                             (box[0] + 5 + progress_width, box[3] - 5), (0, 255, 0), -1)  # Green progress
            
            self.selection_boxes.append((name, box))

    def draw_question_type_selection(self, frame, w, h):
        # Header with dark blue background
        cv2.rectangle(frame, (0, 0), (w, 100), (139, 69, 19), -1)  # Dark blue background
        cv2.putText(frame, "Step 2/3: Choose Question Type", (20, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255, 255, 255), 3)  # White bold text
        cv2.putText(frame, f"Welcome {self.selected_name}! Point to select quiz type", (20, 65), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)  # White bold text
        
        # Center question type boxes - made bigger
        self.selection_boxes = []
        available_types = []
        
        # Only show types that have questions - ADD DRAG_DROP
        if self.questions.get("multiple_choice", []):
            available_types.append(("multiple_choice", "Multiple Choice"))
        if self.questions.get("true_false", []):
            available_types.append(("true_false", "True/False"))
        if self.questions.get("drag_drop", []):
            available_types.append(("drag_drop", "Drag & Drop"))
        
        if not available_types:
            cv2.putText(frame, "No questions available!", (w//2 - 200, h//2), 
                       cv2.FONT_HERSHEY_SIMPLEX, 1.5, (243, 139, 168), 3)
            return
        
        box_width = 600
        box_height = 120
        spacing = 60
        start_y = 250
        
        for i, (qtype, display_name) in enumerate(available_types):
            y = start_y + (i * (box_height + spacing))
            x = (w - box_width) // 2  # Center horizontally
            box = [x, y, x + box_width, y + box_height]
            
            # Highlight if hovering
            color = (137, 180, 250) if self.hover_option == qtype else (139, 69, 19)
            thickness = 6 if self.hover_option == qtype else 3
            
            cv2.rectangle(frame, (box[0], box[1]), (box[2], box[3]), color, thickness)
            cv2.rectangle(frame, (box[0]+3, box[1]+3), (box[2]-3, box[3]-3), (139, 69, 19), -1)
            
            # Center type name text
            text_size = cv2.getTextSize(display_name, cv2.FONT_HERSHEY_SIMPLEX, 1.5, 4)[0]
            text_x = box[0] + (box_width - text_size[0]) // 2
            text_y = box[1] + (box_height + text_size[1]) // 2
            cv2.putText(frame, display_name, (text_x, text_y), 
                       cv2.FONT_HERSHEY_SIMPLEX, 1.5, (255, 255, 255), 4)
            
            # Draw selection progress
            if self.hover_option == qtype and self.selection_timer > 0:
                progress_width = int((self.selection_timer / self.selection_threshold) * (box[2] - box[0] - 10))
                cv2.rectangle(frame, (box[0] + 5, box[3] - 25), 
                             (box[0] + 5 + progress_width, box[3] - 5), (0, 255, 0), -1)
        
            self.selection_boxes.append((qtype, box))

    def draw_quiz_interface(self, frame, question, w, h):
        # Header with dark blue background
        cv2.rectangle(frame, (0, 0), (w, 100), (139, 69, 19), -1)  # Dark blue background
        cv2.putText(frame, f"Question {self.current_question_idx + 1}/{len(self.current_questions)}", 
                   (20, 30), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255, 255, 255), 3)  # White bold text
        cv2.putText(frame, f"Score: {self.student_score}", 
                   (20, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)  # White bold text
        
        # Show instruction based on question type
        if self.selected_qtype == "drag_drop":
            if self.dd_selection_mode:
                cv2.putText(frame, "Point to items in correct order", (20, 85), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
            else:
                cv2.putText(frame, "Point to CONFIRM to submit your answer", (20, 85), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
        elif self.question_answered:
            cv2.putText(frame, "Answer selected! Moving to next question...", (20, 85), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
        else:
            cv2.putText(frame, "Point to your answer and hold for 2 seconds", (20, 85), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
        
        # Draw question text
        question_text = question.get('question', '')
        max_chars_per_line = 35
        question_lines = []
        words = question_text.split()
        current_line = ""
        
        for word in words:
            if len(current_line + " " + word) <= max_chars_per_line:
                current_line += " " + word if current_line else word
            else:
                if current_line:
                    question_lines.append(current_line)
                current_line = word
        if current_line:
            question_lines.append(current_line)
        
        question_start_y = 180
        for i, line in enumerate(question_lines):
            text_size = cv2.getTextSize(line, cv2.FONT_HERSHEY_SIMPLEX, 1.8, 5)[0]
            text_x = (w - text_size[0]) // 2
            text_y = question_start_y + (i * 60)
            
            cv2.rectangle(frame, (text_x - 20, text_y - 40), (text_x + text_size[0] + 20, text_y + 20), (139, 69, 19), -1)
            cv2.putText(frame, line, (text_x, text_y), 
                       cv2.FONT_HERSHEY_SIMPLEX, 1.8, (255, 255, 255), 5)
        
        answer_start_y = question_start_y + (len(question_lines) * 60) + 70
        
        # Draw interface based on question type
        if self.selected_qtype == "drag_drop":
            self.draw_drag_drop_interface(frame, question, w, h, answer_start_y)
        elif self.selected_qtype == "multiple_choice":
            # Center multiple choice options - made bigger
            self.selection_boxes = []
            for i, (key, value) in enumerate(question.get("options", {}).items()):
                y = answer_start_y + (i * 110)  # Increased spacing
                
                # Calculate box width based on text
                option_text = f"{key}) {value}"
                text_size = cv2.getTextSize(option_text, cv2.FONT_HERSHEY_SIMPLEX, 1.2, 3)[0]  # Increased font
                box_width = max(500, text_size[0] + 50)  # Increased min width
                
                # Center the box
                box_x = (w - box_width) // 2
                box = [box_x, y, box_x + box_width, y + 90]  # Increased height
                
                # Highlight if hovering
                color = (137, 180, 250) if self.hover_option == key else (139, 69, 19)  # Changed to dark blue
                thickness = 6 if self.hover_option == key else 3
                
                cv2.rectangle(frame, (box[0], box[1]), (box[2], box[3]), color, thickness)
                cv2.rectangle(frame, (box[0]+3, box[1]+3), (box[2]-3, box[3]-3), (139, 69, 19), -1)  # Dark blue background
                
                # Center the option text within the box - white bold and larger
                text_x = box[0] + (box_width - text_size[0]) // 2
                text_y = box[1] + 55  # Adjusted for larger box
                cv2.putText(frame, option_text, (text_x, text_y), 
                           cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255, 255, 255), 3)  # Larger text
                
                # Draw selection progress with green color
                if self.hover_option == key and self.selection_timer > 0 and not self.question_answered:
                    progress_width = int((self.selection_timer / self.selection_threshold) * (box[2] - box[0] - 10))
                    cv2.rectangle(frame, (box[0] + 5, box[3] - 20), 
                                 (box[0] + 5 + progress_width, box[3] - 5), (0, 255, 0), -1)  # Green progress
                
                self.selection_boxes.append((key, box))
            
        elif self.selected_qtype == "true_false":
            # Center True/False boxes - made bigger
            box_width = 300  # Increased from 250
            box_height = 140  # Increased from 120
            spacing = 60  # Increased spacing
            total_width = (box_width * 2) + spacing
            start_x = (w - total_width) // 2
            
            # True box
            box_t = [start_x, answer_start_y, start_x + box_width, answer_start_y + box_height]
            color_t = (137, 180, 250) if self.hover_option == "True" else (139, 69, 19)  # Changed to dark blue
            thickness_t = 6 if self.hover_option == "True" else 3
            
            cv2.rectangle(frame, (box_t[0], box_t[1]), (box_t[2], box_t[3]), color_t, thickness_t)
            cv2.rectangle(frame, (box_t[0]+3, box_t[1]+3), (box_t[2]-3, box_t[3]-3), (139, 69, 19), -1)  # Dark blue background
            
            # Center TRUE text - white bold and larger
            true_text_size = cv2.getTextSize("TRUE", cv2.FONT_HERSHEY_SIMPLEX, 2.0, 5)[0]  # Increased from 1.8, 4
            true_text_x = box_t[0] + (box_width - true_text_size[0]) // 2
            true_text_y = box_t[1] + (box_height + true_text_size[1]) // 2
            cv2.putText(frame, "TRUE", (true_text_x, true_text_y), 
                       cv2.FONT_HERSHEY_SIMPLEX, 2.0, (255, 255, 255), 5)  # Larger and bolder text
            
            # False box
            box_f = [start_x + box_width + spacing, answer_start_y, start_x + box_width + spacing + box_width, answer_start_y + box_height]
            color_f = (137, 180, 250) if self.hover_option == "False" else (139, 69, 19)  # Changed to dark blue
            thickness_f = 6 if self.hover_option == "False" else 3
            
            cv2.rectangle(frame, (box_f[0], box_f[1]), (box_f[2], box_f[3]), color_f, thickness_f)
            cv2.rectangle(frame, (box_f[0]+3, box_f[1]+3), (box_f[2]-3, box_f[3]-3), (139, 69, 19), -1)  # Dark blue background
            
            # Center FALSE text - white bold and larger
            false_text_size = cv2.getTextSize("FALSE", cv2.FONT_HERSHEY_SIMPLEX, 2.0, 5)[0]  # Increased from 1.8, 4
            false_text_x = box_f[0] + (box_width - false_text_size[0]) // 2
            false_text_y = box_f[1] + (box_height + false_text_size[1]) // 2
            cv2.putText(frame, "FALSE", (false_text_x, false_text_y), 
                       cv2.FONT_HERSHEY_SIMPLEX, 2.0, (255, 255, 255), 5)  # Larger and bolder text
            
            # Draw selection progress with green color
            if not self.question_answered:
                if self.hover_option == "True" and self.selection_timer > 0:
                    progress_width = int((self.selection_timer / self.selection_threshold) * (box_t[2] - box_t[0] - 10))
                    cv2.rectangle(frame, (box_t[0] + 5, box_t[3] - 25), 
                                 (box_t[0] + 5 + progress_width, box_t[3] - 5), (0, 255, 0), -1)  # Green progress
                elif self.hover_option == "False" and self.selection_timer > 0:
                    progress_width = int((self.selection_timer / self.selection_threshold) * (box_f[2] - box_f[0] - 10))
                    cv2.rectangle(frame, (box_f[0] + 5, box_f[3] - 25), 
                                 (box_f[0] + 5 + progress_width, box_f[3] - 5), (0, 255, 0), -1)  # Green progress
            
            self.selection_boxes = [("True", box_t), ("False", box_f)]

    def draw_results_interface(self, frame, w, h):
        # Header with dark blue background
        cv2.rectangle(frame, (0, 0), (w, 100), (139, 69, 19), -1)  # Dark blue background
        
        # Center "Quiz Complete!" text with white bold
        complete_text = "Quiz Complete!"
        text_size = cv2.getTextSize(complete_text, cv2.FONT_HERSHEY_SIMPLEX, 1.5, 4)[0]
        text_x = (w - text_size[0]) // 2
        cv2.putText(frame, complete_text, (text_x, 50), 
                   cv2.FONT_HERSHEY_SIMPLEX, 1.5, (255, 255, 255), 4)  # White bold text
        
        # Center results with dark blue text - moved down
        score_text = f"Final Score: {self.student_score}/{len(self.current_questions)}"
        score_size = cv2.getTextSize(score_text, cv2.FONT_HERSHEY_SIMPLEX, 1.3, 3)[0]
        score_x = (w - score_size[0]) // 2
        cv2.putText(frame, score_text, (score_x, 180), 
                   cv2.FONT_HERSHEY_SIMPLEX, 1.3, (139, 69, 19), 3)  # Dark blue text
        
        percentage = (self.student_score / len(self.current_questions)) * 100 if self.current_questions else 0
        perc_text = f"Percentage: {percentage:.1f}%"
        perc_size = cv2.getTextSize(perc_text, cv2.FONT_HERSHEY_SIMPLEX, 1.1, 2)[0]
        perc_x = (w - perc_size[0]) // 2
        cv2.putText(frame, perc_text, (perc_x, 230), 
                   cv2.FONT_HERSHEY_SIMPLEX, 1.1, (139, 69, 19), 2)  # Dark blue text
        
        # Center action buttons - moved down and made bigger
        self.selection_boxes = []
        
        box_width = 500  # Increased from 400
        box_height = 100  # Increased from 80
        spacing = 40  # Increased spacing
        start_y = 320  # Moved down from 280
        
        # Restart button
        restart_x = (w - box_width) // 2
        restart_box = [restart_x, start_y, restart_x + box_width, start_y + box_height]
        color_restart = (137, 180, 250) if self.hover_option == "restart" else (139, 69, 19)  # Changed to dark blue
        thickness_restart = 6 if self.hover_option == "restart" else 3  # Increased thickness
        
        cv2.rectangle(frame, (restart_box[0], restart_box[1]), (restart_box[2], restart_box[3]), color_restart, thickness_restart)
        cv2.rectangle(frame, (restart_box[0]+3, restart_box[1]+3), (restart_box[2]-3, restart_box[3]-3), (139, 69, 19), -1)  # Dark blue background
        
        restart_text = "Take Another Quiz"
        restart_text_size = cv2.getTextSize(restart_text, cv2.FONT_HERSHEY_SIMPLEX, 1.1, 3)[0]  # Increased font
        restart_text_x = restart_box[0] + (box_width - restart_text_size[0]) // 2
        cv2.putText(frame, restart_text, (restart_text_x, restart_box[1] + 60), 
                   cv2.FONT_HERSHEY_SIMPLEX, 1.1, (255, 255, 255), 3)  # Larger text
        
        # Home button
        home_y = start_y + box_height + spacing
        home_x = (w - box_width) // 2
        home_box = [home_x, home_y, home_x + box_width, home_y + box_height]
        color_home = (137, 180, 250) if self.hover_option == "home" else (139, 69, 19)  # Changed to dark blue
        thickness_home = 6 if self.hover_option == "home" else 3  # Increased thickness
        
        cv2.rectangle(frame, (home_box[0], home_box[1]), (home_box[2], home_box[3]), color_home, thickness_home)
        cv2.rectangle(frame, (home_box[0]+3, home_box[1]+3), (home_box[2]-3, home_box[3]-3), (139, 69, 19), -1)  # Dark blue background
        
        home_text = "Back to Home"
        home_text_size = cv2.getTextSize(home_text, cv2.FONT_HERSHEY_SIMPLEX, 1.1, 3)[0]  # Increased font
        home_text_x = home_box[0] + (box_width - home_text_size[0]) // 2
        cv2.putText(frame, home_text, (home_text_x, home_box[1] + 60), 
                   cv2.FONT_HERSHEY_SIMPLEX, 1.1, (255, 255, 255), 3)  # Larger text
        
        # Draw selection progress with green color
        if self.hover_option == "restart" and self.selection_timer > 0:
            progress_width = int((self.selection_timer / self.selection_threshold) * (restart_box[2] - restart_box[0] - 10))
            cv2.rectangle(frame, (restart_box[0] + 5, restart_box[3] - 20), 
                         (restart_box[0] + 5 + progress_width, restart_box[3] - 5), (0, 255, 0), -1)  # Green progress
        elif self.hover_option == "home" and self.selection_timer > 0:
            progress_width = int((self.selection_timer / self.selection_threshold) * (home_box[2] - home_box[0] - 10))
            cv2.rectangle(frame, (home_box[0] + 5, home_box[3] - 20), 
                         (home_box[0] + 5 + progress_width, home_box[3] - 5), (0, 255, 0), -1)  # Green progress
        
        self.selection_boxes = [("restart", restart_box), ("home", home_box)]

    def handle_camera_gestures(self, frame, result, w, h):
        lms = result.multi_hand_landmarks[0]
        self.mp_drawing.draw_landmarks(frame, lms, self.mp_hands.HAND_CONNECTIONS)
        
        # Get fingertip position
        tip = lms.landmark[8]  # Index finger tip
        px, py = int(tip.x * w), int(tip.y * h)
        
        # Draw cursor
        cv2.circle(frame, (px, py), 15, (137, 180, 250), -1)
        cv2.circle(frame, (px, py), 20, (205, 214, 244), 2)
        
        # Check what option is being pointed at - ONLY within button boundaries
        current_hover = None
        for option, box in self.selection_boxes:
            # More precise boundary checking - finger must be INSIDE the button
            if (box[0] + 10) <= px <= (box[2] - 10) and (box[1] + 10) <= py <= (box[3] - 10):
                current_hover = option
                break
    
        # Handle selection timing - more strict for quiz questions
        if self.student_step == 3 and self.question_answered:
            # If question is already answered, don't process more selections
            self.selection_timer = 0
            self.hover_option = None
            return
    
        # Only process selection if hovering over a valid button area
        if current_hover is not None:
            if current_hover == self.hover_option:
                self.selection_timer += 2  # INCREASED from 1 to 2 for faster progress
                if self.selection_timer >= self.selection_threshold:
                    self.handle_selection(current_hover)
                    self.selection_timer = 0
                    self.hover_option = None
            else:
                self.hover_option = current_hover
                self.selection_timer = 0
        else:
            # Reset timer and hover when not pointing at any button
            self.hover_option = None
            self.selection_timer = 0

    def handle_selection(self, selection):
        if self.student_step == 1:  # Name selection
            self.selected_name = selection
            self.student_step = 2
            
        elif self.student_step == 2:  # Question type selection
            self.selected_qtype = selection
            self.current_questions = self.questions.get(selection, [])
            if not self.current_questions:
                return
            self.current_question_idx = 0
            self.student_score = 0
            self.question_answered = False
            
            # Reset drag and drop variables
            self.dd_selected_items = []
            self.dd_selection_mode = True
            
            self.student_step = 3
            
        elif self.student_step == 3:  # Quiz answers
            if not self.question_answered and self.current_question_idx < len(self.current_questions):
                question = self.current_questions[self.current_question_idx]
                
                if self.selected_qtype == "drag_drop":
                    if selection == "reset":
                        # Reset the selection - clear all selected items
                        self.dd_selected_items = []
                        self.dd_selection_mode = True
                        # Don't change question_answered or move to next question
                        return
                        
                    elif selection == "confirm":
                        # Check if order is correct
                        correct_order = question.get("correct_order", {})
                        is_correct = True
                        
                        for i, item_key in enumerate(self.dd_selected_items):
                            expected_position = correct_order.get(item_key, -1)
                            if expected_position != i + 1:
                                is_correct = False
                                break
                        
                        if is_correct:
                            self.student_score += 1
                        
                        self.question_answered = True
                        self.dd_selected_items = []
                        self.dd_selection_mode = True
                        
                        def move_to_next():
                            self.current_question_idx += 1
                            self.question_answered = False
                            if self.current_question_idx >= len(self.current_questions):
                                self.save_score(self.selected_name, self.student_score)
                                self.student_step = 4
                        
                        threading.Timer(2.0, move_to_next).start()
                        
                    elif selection not in self.dd_selected_items:
                        # Add item to selection
                        self.dd_selected_items.append(selection)
                        
                else:  # Multiple choice or True/False
                    is_correct = False
                    
                    if self.selected_qtype == "multiple_choice":
                        correct_answers = question.get("correct", question.get("answer", []))
                        if isinstance(correct_answers, str):
                            correct_answers = [correct_answers]
                        is_correct = selection in correct_answers
                    else:  # true_false
                        is_correct = selection == question.get("answer", "")
                    
                    if is_correct:
                        self.student_score += 1
                    
                    self.question_answered = True
                    
                    def move_to_next():
                        self.current_question_idx += 1
                        self.question_answered = False
                        if self.current_question_idx >= len(self.current_questions):
                            self.save_score(self.selected_name, self.student_score)
                            self.student_step = 4
                    
                    threading.Timer(2.0, move_to_next).start()
                
        elif self.student_step == 4:  # Results actions
            if selection == "restart":
                self.student_step = 1
                self.selected_name = None
                self.selected_qtype = None
                self.current_questions = []
                self.current_question_idx = 0
                self.student_score = 0
                self.question_answered = False
                self.dd_selected_items = []
                self.dd_selection_mode = True
            elif selection == "home":
                # Set flag to exit camera loop and return to main menu
                self.exit_camera = True

    # -------- Helper methods for adding questions --------
    def add_mc(self):
        q = self.mc_q.get().strip()
        if not q:
            messagebox.showerror("Error", "Enter question")
            return
        options = {}
        correct = []
        for k, (e, chk) in self.mc_opts.items():
            opt_text = e.get().strip()
            if opt_text:  # Only add non-empty options
                options[k] = opt_text
                if chk.get():
                    correct.append(k)
        
        if not options or not correct:
            messagebox.showerror("Error", "Fill at least one option and select correct answer(s)")
            return
            
        self.questions["multiple_choice"].append({"question": q, "options": options, "correct": correct})
        self.save_questions()
        
        # Clear fields
        self.mc_q.delete(0, tk.END)
        for e, c in self.mc_opts.values():
            e.delete(0, tk.END)
            c.set(False)
        messagebox.showinfo("Saved", "Question added successfully!")

    def add_tf(self):
        q = self.tf_q.get().strip()
        if not q:
            messagebox.showerror("Error", "Enter question")
            return
        self.questions["true_false"].append({"question": q, "answer": self.tf_var.get()})
        self.save_questions()
        self.tf_q.delete(0, tk.END)
        self.tf_var.set("True")
        messagebox.showinfo("Saved", "True/False question added successfully!")

    def add_dd(self):
        q = self.dd_q.get().strip()
        if not q:
            messagebox.showerror("Error", "Enter question")
            return
            
        items = {}
        correct_order = {}
        
        for i, (entry, pos_var) in self.dd_items.items():
            item_text = entry.get().strip()
            if item_text:
                try:
                    position = int(pos_var.get())
                    if 1 <= position <= 4:
                        items[f"item_{i}"] = item_text
                        correct_order[f"item_{i}"] = position
                    else:
                        messagebox.showerror("Error", f"Position for item {i+1} must be between 1-4!")
                        return
                except ValueError:
                    messagebox.showerror("Error", f"Position for item {i+1} must be a number!")
                    return
        
        if len(items) < 2:
            messagebox.showerror("Error", "Enter at least 2 items!")
            return
            
        # Check for duplicate positions
        positions = list(correct_order.values())
        if len(positions) != len(set(positions)):
            messagebox.showerror("Error", "Each item must have a unique position!")
            return
        
        self.questions["drag_drop"].append({
            "question": q,
            "items": items,
            "correct_order": correct_order
        })
        self.save_questions()
        
        # Clear form
        self.dd_q.delete(0, tk.END)
        for i, (entry, pos_var) in self.dd_items.items():
            entry.delete(0, tk.END)
            pos_var.set(str(i+1))
        
        messagebox.showinfo("Saved", "Drag & Drop question added successfully!")

    def add_student(self):
        name = self.student_entry.get().strip()
        if not name:
            messagebox.showerror("Error", "Enter student name")
            return
        if name not in self.students:
            self.students.append(name)
            self.save_students()
            self.student_entry.delete(0, tk.END)
            # Refresh the student list display
            self.refresh_student_list()
            messagebox.showinfo("Added", f"Student '{name}' added successfully!")
        else:
            messagebox.showwarning("Warning", f"Student '{name}' already exists!")
            self.student_entry.delete(0, tk.END)

    def load_scores(self):
        """Load and display total scores for each student"""
        self.score_text.delete("1.0", tk.END)
        
        if not os.path.exists(self.scores_file):
            self.score_text.insert(tk.END, "üìä STUDENT TOTAL SCORES\n")
            self.score_text.insert(tk.END, "=" * 50 + "\n\n")
            self.score_text.insert(tk.END, "No scores recorded yet.\n\n")
            self.score_text.insert(tk.END, "‚ÑπÔ∏è  Total scores will appear here after students take quizzes.\n")
            self.score_text.insert(tk.END, "Each student's scores from multiple quiz attempts will be summed.")
            return
        
        try:
            wb = load_workbook(self.scores_file)
            ws = wb.active
            
            # Dictionary to store total scores for each student
            student_totals = {}
            student_attempts = {}  # Track number of attempts per student
            
            # Calculate total scores for each student
            for row in ws.iter_rows(min_row=2, values_only=True):  # Skip header row
                if row[0] and row[1] is not None:  # Check both name and score exist
                    name = row[0]
                    score = row[1]
                    
                    if name in student_totals:
                        student_totals[name] += score
                        student_attempts[name] += 1
                    else:
                        student_totals[name] = score
                        student_attempts[name] = 1
            
            # Display the results
            self.score_text.insert(tk.END, "üìä STUDENT TOTAL SCORES\n")
            self.score_text.insert(tk.END, "=" * 60 + "\n\n")
            
            if not student_totals:
                self.score_text.insert(tk.END, "No scores recorded yet.\n")
                return
            
            # Sort students by total score (highest first)
            sorted_students = sorted(student_totals.items(), key=lambda x: x[1], reverse=True)
            
            # Display header
            self.score_text.insert(tk.END, f"{'RANK':<6} {'STUDENT NAME':<25} {'TOTAL SCORE':<12} {'ATTEMPTS':<10} {'AVERAGE':<8}\n")
            self.score_text.insert(tk.END, "-" * 70 + "\n")
            
            # Display each student's total scores
            for rank, (name, total_score) in enumerate(sorted_students, 1):
                attempts = student_attempts[name]
                average = total_score / attempts if attempts > 0 else 0
                
                # Add rank indicator
                if rank == 1:
                    rank_icon = "ü•á"
                elif rank == 2:
                    rank_icon = "ü•à"
                elif rank == 3:
                    rank_icon = "ü•â"
                else:
                    rank_icon = f"#{rank}"
                
                self.score_text.insert(tk.END, f"{rank_icon:<6} {name:<25} {total_score:<12} {attempts:<10} {average:.1f}\n")
            
            # Add summary statistics
            self.score_text.insert(tk.END, "\n" + "=" * 60 + "\n")
            self.score_text.insert(tk.END, "üìà SUMMARY STATISTICS\n")
            self.score_text.insert(tk.END, "-" * 30 + "\n")
            
            total_students = len(student_totals)
            total_attempts = sum(student_attempts.values())
            highest_score = max(student_totals.values()) if student_totals else 0
            lowest_score = min(student_totals.values()) if student_totals else 0
            average_total = sum(student_totals.values()) / total_students if total_students > 0 else 0
            
            self.score_text.insert(tk.END, f"üë• Total Students: {total_students}\n")
            self.score_text.insert(tk.END, f"üìù Total Quiz Attempts: {total_attempts}\n")
            self.score_text.insert(tk.END, f"üéØ Highest Total Score: {highest_score}\n")
            self.score_text.insert(tk.END, f"üìâ Lowest Total Score: {lowest_score}\n")
            self.score_text.insert(tk.END, f"üìä Average Total Score: {average_total:.1f}\n")
            
            # Show top performer
            if sorted_students:
                top_student = sorted_students[0]
                self.score_text.insert(tk.END, f"\nüèÜ TOP PERFORMER: {top_student[0]} with {top_student[1]} total points!")
                
        except Exception as e:
            self.score_text.delete("1.0", tk.END)
            self.score_text.insert(tk.END, f"‚ùå Error loading scores: {str(e)}\n\n")
            self.score_text.insert(tk.END, "Please check if the scores file is corrupted or in use by another program.")

    def clear_all_scores(self):
        """Clear all scores with confirmation"""
        result = messagebox.askyesno(
            "Clear All Scores", 
            "Are you sure you want to delete ALL student scores?\n\nThis action cannot be undone!",
            icon="warning"
        )
        
        if result:
            try:
                if os.path.exists(self.scores_file):
                    os.remove(self.scores_file)
                
                # Create new empty scores file with header
                wb = Workbook()
                ws = wb.active
                ws.append(["Name", "Score"])
                wb.save(self.scores_file)
                
                self.load_scores()  # Refresh the display
                messagebox.showinfo("Success", "All scores have been cleared!")
                
            except Exception as e:
                messagebox.showerror("Error", f"Could not clear scores: {str(e)}")

    def refresh_student_list(self):
        """Refresh the students listbox display"""
        # Clear current listbox
        self.students_listbox.delete(0, tk.END)
        
        # Reload students from file
        self.students = self.load_students()
        
        # Populate listbox
        for i, student in enumerate(self.students, 1):
            self.students_listbox.insert(tk.END, f"{i:2d}. {student}")
        
        # Update count label
        count = len(self.students)
        if count == 0:
            self.student_count_label.config(text="üìù No students added yet", fg=self.colors["warning"])
        elif count == 1:
            self.student_count_label.config(text="üìù 1 student registered", fg=self.colors["success"])
        else:
            self.student_count_label.config(text=f"üìù {count} students registered", fg=self.colors["success"])

    def delete_student(self):
        """Delete selected student with confirmation"""
        selection = self.students_listbox.curselection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a student to delete!")
            return
        
        selected_index = selection[0]
        student_name = self.students[selected_index]
        
        # Confirmation dialog
        result = messagebox.askyesno(
            "Delete Student", 
            f"Are you sure you want to delete '{student_name}'?\n\nThis action cannot be undone!",
            icon="warning"
        )
        
        if result:
            try:
                # Remove student from list
                self.students.pop(selected_index)
                
                # Save updated list
                self.save_students()
                
                # Refresh display
                self.refresh_student_list()
                
                messagebox.showinfo("Success", f"Student '{student_name}' has been deleted!")
                
            except Exception as e:
                messagebox.showerror("Error", f"Could not delete student: {str(e)}")

    def clear_all_students(self):
        """Clear all students with confirmation"""
        if not self.students:
            messagebox.showinfo("No Students", "There are no students to delete!")
            return
        
        result = messagebox.askyesno(
            "Clear All Students", 
            f"Are you sure you want to delete ALL {len(self.students)} students?\n\nThis action cannot be undone!",
            icon="warning"
        )
        
        if result:
            try:
                # Clear students list
                self.students = []
                
                # Save empty list
                self.save_students()
                
                # Refresh display
                self.refresh_student_list()
                
                messagebox.showinfo("Success", "All students have been deleted!")
                
            except Exception as e:
                messagebox.showerror("Error", f"Could not clear students: {str(e)}")

    def draw_drag_drop_interface(self, frame, question, w, h, start_y):
        items = question.get("items", {})
        self.selection_boxes = []
        
        if self.dd_selection_mode:
            # Show available items to select - with dark blue background
            available_text = "Available Items:"
            available_size = cv2.getTextSize(available_text, cv2.FONT_HERSHEY_SIMPLEX, 1.2,  3)[0]
            cv2.rectangle(frame, (40, start_y - 50), (60 + available_size[0], start_y - 10), (139, 69, 19), -1)  # Dark blue background
            cv2.putText(frame, available_text, (50, start_y - 20), 
                       cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255, 255, 255), 3)  # White text
            
            # Show selected order on the right - with dark blue background
            if self.dd_selected_items:
                order_text = "Your Order:"
                order_size = cv2.getTextSize(order_text, cv2.FONT_HERSHEY_SIMPLEX, 1.2, 3)[0]
                cv2.rectangle(frame, (w - 310, start_y - 50), (w - 290 + order_size[0], start_y - 10), (139, 69, 19), -1)  # Dark blue background
                cv2.putText(frame, order_text, (w - 300, start_y - 20), 
                           cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255, 255, 255), 3)  # White text
                
                for i, item_key in enumerate(self.dd_selected_items):
                    item_text = items.get(item_key, "")
                    order_item_text = f"{i+1}. {item_text}"
                    y_pos = start_y + (i * 50)
                    
                    # Add dark blue background for each order item
                    order_item_size = cv2.getTextSize(order_item_text, cv2.FONT_HERSHEY_SIMPLEX, 0.8, 2)[0]
                    cv2.rectangle(frame, (w - 310, y_pos - 20), (w - 290 + order_item_size[0], y_pos + 10), (139, 69, 19), -1)  # Dark blue background
                    cv2.putText(frame, order_item_text, (w - 300, y_pos), 
                               cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)  # Green text for selected items
        
        # Draw available items
        box_height = 80
        box_spacing = 20
        available_items = [(k, v) for k, v in items.items() if k not in self.dd_selected_items]
        
        for i, (item_key, item_text) in enumerate(available_items):
            y = start_y + (i * (box_height + box_spacing))
            text_size = cv2.getTextSize(item_text, cv2.FONT_HERSHEY_SIMPLEX, 1.0, 2)[0]
            box_width = max(400, text_size[0] + 40)
            x = 50
            box = [x, y, x + box_width, y + box_height]
            
            color = (137, 180, 250) if self.hover_option == item_key else (139, 69, 19)
            thickness = 6 if self.hover_option == item_key else 3
            
            cv2.rectangle(frame, (box[0], box[1]), (box[2], box[3]), color, thickness)
            cv2.rectangle(frame, (box[0]+3, box[1]+3), (box[2]-3, box[3]-3), (139, 69, 19), -1)
            
            text_x = box[0] + 20
            text_y = box[1] + 50
            cv2.putText(frame, item_text, (text_x, text_y), 
                       cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255, 255, 255), 2)
            
            if self.hover_option == item_key and self.selection_timer > 0:
                progress_width = int((self.selection_timer / self.selection_threshold) * (box[2] - box[0] - 10))
                cv2.rectangle(frame, (box[0] + 5, box[3] - 15), 
                             (box[0] + 5 + progress_width, box[3] - 5), (0, 255, 0), -1)
            
            self.selection_boxes.append((item_key, box))
        
        # Add RESET button if any items are selected - with blue background and white text
        if self.dd_selected_items:
            reset_y = start_y + len(available_items) * (box_height + box_spacing) + 20
            reset_box = [w//2 - 300, reset_y, w//2 - 50, reset_y + 60]
            
            # Use blue color for reset button instead of pink
            color = (137, 180, 250) if self.hover_option == "reset" else (139, 69, 19)  # Blue colors
            thickness = 6 if self.hover_option == "reset" else 3
            
            cv2.rectangle(frame, (reset_box[0], reset_box[1]), (reset_box[2], reset_box[3]), color, thickness)
            cv2.rectangle(frame, (reset_box[0]+3, reset_box[1]+3), (reset_box[2]-3, reset_box[3]-3), (139, 69, 19), -1)  # Dark blue background
            
            cv2.putText(frame, "RESET", (reset_box[0] + 75, reset_box[1] + 40), 
                       cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255, 255, 255), 3)  # White text
            
            if self.hover_option == "reset" and self.selection_timer > 0:
                progress_width = int((self.selection_timer / self.selection_threshold) * (reset_box[2] - reset_box[0] - 10))
                cv2.rectangle(frame, (reset_box[0] + 5, reset_box[3] - 15), 
                             (reset_box[0] + 5 + progress_width, reset_box[3] - 5), (255, 255, 0), -1)
            
            self.selection_boxes.append(("reset", reset_box))
        
        # Add confirm button if all items selected
        if len(self.dd_selected_items) == len(items):
            confirm_y = start_y + len(available_items) * (box_height + box_spacing) + 20
            confirm_box = [w//2 + 50, confirm_y, w//2 + 300, confirm_y + 60]  # Moved to the right
            
            color = (137, 180, 250) if self.hover_option == "confirm" else (0, 255, 0)
            thickness = 6 if self.hover_option == "confirm" else 3
            
            cv2.rectangle(frame, (confirm_box[0], confirm_box[1]), (confirm_box[2], confirm_box[3]), color, thickness)
            cv2.rectangle(frame, (confirm_box[0]+3, confirm_box[1]+3), (confirm_box[2]-3, confirm_box[3]-3), (0, 255, 0), -1)
            
            cv2.putText(frame, "CONFIRM", (confirm_box[0] + 60, confirm_box[1] + 40), 
                       cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255, 255, 255), 3)
            
            if self.hover_option == "confirm" and self.selection_timer > 0:
                progress_width = int((self.selection_timer / self.selection_threshold) * (confirm_box[2] - confirm_box[0] - 10))
                cv2.rectangle(frame, (confirm_box[0] + 5, confirm_box[3] - 15), 
                             (confirm_box[0] + 5 + progress_width, confirm_box[3] - 5), (255, 255, 0), -1)
            
            self.selection_boxes.append(("confirm", confirm_box))
        
        # Add instruction text at the bottom - with dark blue background
        instruction_y = h - 50
        if self.dd_selected_items:
            instruction_text = "Point to RESET to clear selections or CONFIRM when done"
        else:
            instruction_text = "Point to items in the correct order"
        
        # Add dark blue background for instruction text
        instruction_size = cv2.getTextSize(instruction_text, cv2.FONT_HERSHEY_SIMPLEX, 0.8, 2)[0]
        cv2.rectangle(frame, (40, instruction_y - 25), (60 + instruction_size[0], instruction_y + 5), (139, 69, 19), -1)  # Dark blue background
        cv2.putText(frame, instruction_text, (50, instruction_y), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)  # White text

# Move this outside the class - at module level (no indentation)
if __name__ == "__main__":
    app = BasicQuiz()
    app.root.mainloop()
